---
published: false
layout: post
tag: dart
original: http://mrale.ph/blog/2017/01/08/the-fear-of-dart-mirrors.html
title: The fear of dart:mirrors
author: "Vyacheslav Egorov"
translator: "Ирина Смышляева"

---
[dart:mirrors](https://api.dartlang.org/stable/1.21.1/dart-mirrors/dart-mirrors-library.html) должно быть самая непонятая, неправильно используемая и несправедливо забытая из библиотек ядра Dart'а. Она была в языке с самого начала, но по-прежнему окружена туманом неопределенности и отмечена как нестабильная в документации, несмотря на то, что API не менялось уже давно.

dart:mirrors редко оказывается во внимании, потому что это библиотека, которая позволяет метапрограммировать. Рядовому разработчику редко приходится иметь с этим дело напрямую - скорее, это касается авторов билиотек или фреймворков.

И на самом деле, в начале моего пути к этому посту стояло не dart:mirrors, а что-то совсем другое:

## Десериализация JSON

В декабре 2016 я залипал на канал Дарта в Slack (от него отказались в пользу [dart-lang Gitter](https://gitter.im/dart-lang/home)), и увидел что некто, назовем его Максимилиан, спрашивает о том, какие в Дарте есть способы распарсить JSON. Если вы пришли из JavaScript, такой вопрос может удивить - разве сделать это не так же просто, как `JSON.parse(...)` в JavaScript?

Да, так же просто: можно просто использовать `JSON.decode(...)` из встроенной библиотека dart:convert, но есть загвоздка. В JavaScript `JSON.parse` вернет объект, потому что в JS объекты - это бесформенные облака свойств и такой код совершенно нормальный:

    let userData = JSON.parse(str);
    console.log(`Got user ${userData.name} from ${userData.city}`);

Однако каждый объект Дарта имеет фиксированный класс, который полностью определяет его форму. `JSON.decode` может вернуть Map, но не объект  вашего пользовательского типа:

    Map userData = JSON.decode(str);
    console.log("Got user ${userData['name']} from ${userData['city']}");  // OK

    class UserData {
      String name;
      String city;
    }

    UserData userData = JSON.decode(str);  // не OK
    console.log("Got user ${userData.name} from ${userData.city}");

Распространенное решение этой проблемы заключается в написании хелпера для декодирования, умеющего создавать объекты из Maps:

    class UserData {
      String name;
      String city;

      UserData(this.name, this.city);

      UserDate.fromJson(Map m)
          : this(m['name'], m['city']);
    }

    UserData userData = new UserDate.fromJson(JSON.decode(str));
    console.log("Got user ${userData.name} from ${userData.city}");

Но написание такого шаблонного кода не лучший способ провести день. Поэтому в [pub](https://pub.dartlang.org/) можно найти множество пакетов, автоматизирующих это и... [барабанная дробь](https://www.youtube.com/watch?v=mzAfTmC3It0)... некоторые из них используют dart:mirrors.

### Что такое dart:mirrors?

Если вы не знакомы с языком, вероятно вы никогда не слышали слово mirror (зеркало) в контексте языков программирования. Это игра слов: зеркальное апи позволяет программе отражаться (думать о себе). Исторически это пошло от SELF, как и многие другие отличные VM технологии. Посмотрите [пост Gilad Bracha](https://gbracha.blogspot.ru/2010/03/through-looking-glass-darkly.html) и походите по ссылкам, если хотите узнать больше про зеркала и их роль в других системах.

Зеркала существуют, чтобы отвечать на рефлективные вопросы вроде *"Какой тип данного объекта?", "Какие поля/методы у него есть?", "Какой тип поля?", "Какой тип параметра метода?"* и выполнять рефлективные действия *"Получить значение этого поля из того объекта!"* или *"Вызвать этот метод в том объекте!"*.

В JavaScript объекты сами по себе содержат рефлективные возможности: чтобы динамически получить свойство по имени можно просто сделать obj[key], чтобы вызвать метод по имени с динамическим списком аргументов obj[name].apply(obj, args).

Дарт, в свою очередь, инкапсулирует эти возможности в библиотеке dart:mirrors:

import 'dart:mirrors' as mirrors;

    setField(obj, name, value) {
      // Забирает InstanceMirror, который позволяет получить доступ к стейту obj
      final mirror = mirrors.reflect(obj);
      // Устанавливает поле через зеркало
      mirror.setField(new Symbol(name), value);
    }
>     $ git log --oneline -5 --author cbeams --before "Fri Mar 26 2009"


Упс. И сравните это с [более поздними](https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb) коммитами из того же репозитория:

 *насколько хорошо разработчик умеет работать в команде*.

 полезная вещь. Настает время `git blame`, `revert`, `rebase`, `log`,

**Стиль.** Синтаксис разметки, отступы, грамматика, прописные буквы,

1. Ограничьте длину строк в сообщении 72 символами
1. В сообщении пишите что и почему сделано, а не как

Например:

    Обобщите изменения используя меньше 50 символов.

     - Можно добавить список

## Советы

### Полюбите командную строку. Расстаньтесь с IDE.
